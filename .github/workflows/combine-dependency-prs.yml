name: 'Combine Dependency PRs'

# This workflow combines dependency PRs from Dependabot into a single PR
# It only combines PRs that have passed all CI checks (tests, linting, docker build)
# Source PRs are deleted only after the combined PR passes all checks

on:
  workflow_dispatch:
    inputs:
      combineBranchName:
        description: 'Name of the branch to combine PRs into'
        required: true
        default: 'combined-dependency-updates'
      deleteStaleBranch:
        description: 'Delete existing combined branch if it exists'
        type: boolean
        required: true
        default: true
      includeTypes:
        description: 'Dependency types to include (comma-separated: python,docker,github-actions)'
        required: false
        default: 'python,docker,github-actions'

jobs:
  combine-prs:
    runs-on: ubuntu-latest
    permissions:
      contents: write        # Create/delete branches, merge operations
      pull-requests: write   # Create combined PR
      issues: write          # Add labels and post comments

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Combine Dependency PRs
        id: combine-prs
        uses: actions/github-script@v8
        with:
          github-token: ${{secrets.GITHUB_TOKEN}}
          script: |
            const combineBranchName = '${{ github.event.inputs.combineBranchName }}';
            const deleteStaleBranch = ${{ github.event.inputs.deleteStaleBranch }};
            const includeTypesInput = '${{ github.event.inputs.includeTypes }}';
            const includeTypes = includeTypesInput.split(',').map(t => t.trim());

            console.log(`Configuration:`);
            console.log(`  Branch name: ${combineBranchName}`);
            console.log(`  Delete stale branch: ${deleteStaleBranch}`);
            console.log(`  Include types: ${includeTypes.join(', ')}`);

            // Get all open PRs
            const pulls = await github.paginate('GET /repos/:owner/:repo/pulls', {
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open'
            });

            console.log(`\nFound ${pulls.length} open PRs`);

            let eligiblePRs = [];
            let baseBranch = null;
            let baseBranchSHA = null;

            // Filter PRs that meet criteria
            for (const pull of pulls) {
              const labels = pull.labels.map(label => label.name);
              console.log(`\nPR #${pull.number}: ${pull.title}`);
              console.log(`  Labels: ${labels.join(', ')}`);

              // Check if PR has 'dependencies' label
              if (!labels.includes('dependencies')) {
                console.log(`  âŒ Skipping: Missing 'dependencies' label`);
                continue;
              }

              // Check if PR has at least one of the requested dependency type labels
              const hasRequestedType = includeTypes.some(type => labels.includes(type));
              if (!hasRequestedType) {
                console.log(`  âŒ Skipping: Doesn't have any of the requested types (${includeTypes.join(', ')})`);
                continue;
              }

              // Check if title starts with 'chore' prefix
              if (!pull.title.startsWith('chore(deps)') && !pull.title.startsWith('chore:')) {
                console.log(`  âŒ Skipping: Title doesn't start with 'chore(deps)' or 'chore:'`);
                continue;
              }

              // Check if PR has green status (all checks passed)
              console.log(`  Checking CI status...`);

              const stateQuery = `query($owner: String!, $repo: String!, $pull_number: Int!) {
                repository(owner: $owner, name: $repo) {
                  pullRequest(number: $pull_number) {
                    commits(last: 1) {
                      nodes {
                        commit {
                          statusCheckRollup {
                            state
                          }
                        }
                      }
                    }
                  }
                }
              }`;

              const vars = {
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pull.number
              };

              try {
                const result = await github.graphql(stateQuery, vars);
                const commits = result.repository.pullRequest.commits.nodes;
                
                if (!commits || commits.length === 0) {
                  console.log(`  âš ï¸ Skipping: No commits found`);
                  continue;
                }
                
                const commit = commits[0].commit;
                const state = commit.statusCheckRollup?.state;

                console.log(`  Status: ${state || 'NO_STATUS'}`);

                // Only accept SUCCESS state (all checks passed)
                if (state !== 'SUCCESS') {
                  console.log(`  âŒ Skipping: CI status is not SUCCESS (is ${state || 'NO_STATUS'})`);
                  continue;
                }
              } catch (error) {
                console.log(`  âš ï¸ Error checking status: ${error.message}`);
                console.log(`  âŒ Skipping this PR`);
                continue;
              }

              // PR is eligible
              console.log(`  âœ… Eligible for combining`);
              
              const prTypes = labels.filter(l => includeTypes.includes(l));
              eligiblePRs.push({
                number: pull.number,
                title: pull.title,
                branch: pull.head.ref,
                types: prTypes,
                prString: `#${pull.number} ${pull.title}`
              });

              // Use the base branch from the first eligible PR
              if (!baseBranch) {
                baseBranch = pull.base.ref;
                baseBranchSHA = pull.base.sha;
              }
            }

            console.log(`\n=== Summary ===`);
            console.log(`Eligible PRs: ${eligiblePRs.length}`);

            if (eligiblePRs.length === 0) {
              core.setFailed('No eligible PRs found to combine. PRs must have:\n' +
                '  - "dependencies" label\n' +
                `  - One of: ${includeTypes.join(', ')} labels\n` +
                '  - Title starting with "chore(deps)" or "chore:"\n' +
                '  - All CI checks passing (SUCCESS status)');
              return;
            }

            if (eligiblePRs.length === 1) {
              console.log('Only one eligible PR found - no need to combine');
              core.setFailed('Only one eligible PR found. At least 2 PRs are needed to create a combined PR.');
              return;
            }

            console.log('\nEligible PRs:');
            for (const pr of eligiblePRs) {
              console.log(`  - ${pr.prString} [${pr.types.join(', ')}]`);
            }

            // Check if combined branch already exists
            console.log(`\nChecking if branch ${combineBranchName} exists...`);
            try {
              await github.rest.repos.getBranch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                branch: combineBranchName
              });
              
              console.log(`Branch ${combineBranchName} already exists`);
              if (deleteStaleBranch) {
                console.log('Deleting existing branch...');
                await github.rest.git.deleteRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `heads/${combineBranchName}`
                });
                console.log('âœ… Deleted existing branch');
              } else {
                core.setFailed(`Branch ${combineBranchName} already exists. Set deleteStaleBranch to true to delete it.`);
                return;
              }
            } catch (error) {
              // Branch doesn't exist, which is fine
              console.log(`Branch ${combineBranchName} does not exist (this is expected)`);
            }

            // Create combined branch
            console.log(`\nCreating combined branch: ${combineBranchName}`);
            try {
              await github.rest.git.createRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `refs/heads/${combineBranchName}`,
                sha: baseBranchSHA
              });
              console.log('âœ… Combined branch created successfully');
            } catch (error) {
              console.log(error);
              core.setFailed('Failed to create combined branch');
              return;
            }

            // Merge all eligible PRs into combined branch
            let combinedPRs = [];
            let mergeFailedPRs = [];

            console.log('\nMerging PRs into combined branch...');
            for (const pr of eligiblePRs) {
              try {
                await github.rest.repos.merge({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  base: combineBranchName,
                  head: pr.branch,
                });
                console.log(`âœ… Merged: ${pr.prString}`);
                combinedPRs.push(pr);
              } catch (error) {
                console.log(`âŒ Failed to merge: ${pr.prString} - ${error.message}`);
                mergeFailedPRs.push(pr);
              }
            }

            if (combinedPRs.length === 0) {
              core.setFailed('Failed to merge any PRs - likely due to conflicts');
              return;
            }

            // Create combined PR
            console.log('\nCreating combined PR...');
            
            // Group PRs by type for better organization
            const prsByType = {};
            for (const pr of combinedPRs) {
              for (const type of pr.types) {
                if (!prsByType[type]) {
                  prsByType[type] = [];
                }
                prsByType[type].push(pr.prString);
              }
            }

            let body = 'ðŸ”„ **Combined Dependency Updates**\n\n';
            body += 'This PR combines the following dependency update PRs:\n\n';
            
            for (const [type, prs] of Object.entries(prsByType)) {
              body += `### ${type}\n`;
              for (const prString of prs) {
                body += `- ${prString}\n`;
              }
              body += '\n';
            }
            
            body += '---\n\n';
            body += 'âœ… **All source PRs have passed CI checks** (tests, linting, docker build).\n\n';
            body += 'âš ï¸ **Note**: Source PRs will be automatically closed and their branches deleted only after this combined PR is merged and passes all checks.\n';

            if (mergeFailedPRs.length > 0) {
              body += '\n\n## âš ï¸ Merge Conflicts\n\n';
              body += 'The following PRs were excluded due to merge conflicts:\n\n';
              for (const pr of mergeFailedPRs) {
                body += `- ${pr.prString}\n`;
              }
            }

            const { data: combinedPR } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'chore(deps): Combined dependency updates',
              head: combineBranchName,
              base: baseBranch,
              body: body
            });

            console.log(`\nâœ… Combined PR created: #${combinedPR.number}`);
            console.log(`   URL: ${combinedPR.html_url}`);

            // Collect all unique labels from combined PRs
            const allLabels = new Set(['dependencies']);
            for (const pr of combinedPRs) {
              for (const type of pr.types) {
                allLabels.add(type);
              }
            }

            // Add labels to combined PR
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: combinedPR.number,
              labels: Array.from(allLabels)
            });

            // Store PR numbers for reference
            core.setOutput('combined_pr_number', combinedPR.number);
            core.setOutput('source_pr_numbers', JSON.stringify(eligiblePRs.map(pr => pr.number)));

            // Add comment to source PRs
            for (const pr of combinedPRs) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body: `ðŸ”„ This PR has been combined into #${combinedPR.number}. It will be automatically closed after the combined PR is merged and passes all checks.`
              });
            }

            console.log('\nâœ… Workflow completed successfully');
            console.log(`\nNext steps:`);
            console.log(`1. Review combined PR #${combinedPR.number}`);
            console.log(`2. Wait for CI workflows to pass`);
            console.log(`3. Merge the combined PR`);
            console.log(`4. Source PRs will be automatically closed`);

      - name: Workflow Summary
        if: success()
        run: |
          echo "### âœ… Combined PR Created Successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Combined PR: #${{ steps.combine-prs.outputs.combined_pr_number }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Source PRs will be closed after the combined PR is merged and passes all checks." >> $GITHUB_STEP_SUMMARY
